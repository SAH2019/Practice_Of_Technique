# React
## 1.React介绍
    React是一个将数据渲染为HTML视图的开源JavaScript库
      -React是只关注界面的
      -React是不需要用户去操作DOM的
      -采用组件化模式、声明式编码，提高开发效率和组件复用率
      -React Native中可以用React语法进行移动端开发
      -使用虚拟DOM技术 + 优秀的Diffing算法，尽量减少与真实DOM的交互。

## 2.React依赖包
    -babel.js
    -prop-type
    -react.js       //React的核心库
    -react-dom.js   //React的扩展库，用于操作dom

## 3.React起步
```  
    <!-- 1. 引入核心库 -->
    <script type="text/javascript"></script>
    <!-- 2. react-dom，用于支持react操作dom -->
    <script type="text/javascript"></script>
    <!-- 3. babel，用于将jsx转为js -->
    <script type="text/javascript"></script>
    <!-- 4. 编写脚本 -->
    <script type="text/babel">
    -- 注意此时的脚本是type=“text/babel”
    //1.创建虚拟dom
        const VDOM =<h1>hello_react</h1> /*此处不写引号，因为它不是真正的js代码*/ 
    // 2.渲染虚拟dom
        ReactDOM.render(VDOM,document.getElementById("test"))
    </script>
```

## 4.react为什么使用jsx而不是js？
  先看看两种创建虚拟dom的操作： jsx和js的方式：

    1. jsx创建：
       const VDOM =<h1><span>hello_react</span></h1>
    2. js创建：
        const VDOM = React.createElement('h1', {id: "title"}, React.createElement('span', {id: "span"}, "hello,react"))

  由此可见，如果使用js的方式创建虚拟dom，那么当遇见嵌套结构的时候，js代码也需要嵌套，创建过程太过繁琐；
  而jsx就是使用接近html的方式来书写创建虚拟dom

## 5.关于虚拟DOM
    1.虚拟DOM本质上是一个Object对象、
    2.虚拟dom上的属性比较少，而真实的dom上的属性非常多。
    3.虚拟dom最终被react转化为真实的DOM，呈现在页面上。

## 6.JSX的介绍和使用
    1. 全称是JavascriptXML，是react定义的一种类似于XML的JS扩展语法：JS+XML
    2. 本质上是 React.createElement("h1",属性，内容)方法的语法糖
    3. 作用就是简创建虚拟DOM的操作，它既不是字符串，也不是HTML/XML标签，他最终产生了一个JS对象

    4.语法规则：
      （1）写虚拟DOM的时候，不要写引号，可以用括号限定范围
      （2）标签中混入JS表达式的时候要用 {}
      （3）样式的类名指定用 className代替原生中的 class属性
      （4）虚拟DOM的内联样式和原生的写法有区别，要先用{}表示插入js对象，形如style={{color:'#f40',fontSize:16}}
            -- 第一层的{}是表示（2）中的规则，内层的{}是js的对象
            -- 带有 “-”的属性名要使用小驼峰
      （5）虚拟DOM只能有一个根标签。
      （6）标签必须要闭合
      （7）标签的首字母，如果是小写的就将该标签转换成html对应的标签，如果没这个标签，就会报错；如果首字母大写，则react就会把它当成组件去渲染，若组件没定义，就会报错。

## 7. 组件的两种定义方式
### 1. 函数式组件
    // 1. 创建函数式组件
      function Demo(){
        return <h1>我是函数式组件定义的组件</h1>
      }
    // 2.渲染组件到页面
      ReactDOM.render(<Demo/>,document.getElementById("test"))
    /*
      执行了ReactDOM.render(<Demo/>,document.getElementById('test'))   之后发生了什么？
        1.Rract解析组件标签，找到了MyComponent组件。
        2.发现组件是使用函数定义的，随后调用该函数，将返回的虚拟dom转为真实的dom，渲染在页面中。
    */
### 2. 类式组件
   // 1.创建类式组件
    class MyComponent extends React.Component{
      render() {/*放在类的原型对象上的函数，每一个实例可以使用*/
      // render中的this的指向是当前组件的实例对象
        return <h1>我是类式组件定义的组件（是复杂组件）</h1> 
      }
      }
      // 2. 渲染组件
    ReactDOM.render(<MyComponent/>,document.getElementById('test'))
    /*
      执行了ReactDOM.render(<Demo/>,document.getElementById('test'))   之后发生了什么？
        1.Rract解析组件标签，找到了MyComponent组件。
        2.发现组件是使用类定义的，随后new出了组件这个类的实例，并通过该实例调用了render()方法，将render() 返回的虚拟dom转为真实的dom，渲染在页面中。
    */

## 3. 简单组件和复杂组件
      1. 简单组件：   没有状态（state属性）的组件
      2. 复杂组件：   具有状态（state属性）的组件

## 8. 组件实例的三大核心属性
### 1. state
    ①理解： state就是组件中的数据，组件被称为状态机，通过更新组件的state来更新对应的页面显示（重新的render）
    ②注意： 1-state不可以直接使用赋值的方式去更改，必须要使用setState这个API去更改
        2- setState（）更改数据，是进行对象的合并。更改一个数据不会影响其他的
        3- setState（）更改数据，constructor只是在初次渲染时调用；而render函数会调用多次，每一个数据更改都会调用

### 2. props
    ①理解：props用于在组件内接受外部传入的数据
    ②注意： 1-state不可以直接使用赋值的方式去更改，必须要使用setState这个API去更改
        2- setState（）更改数据，是进行对象的合并。更改一个数据不会影响其他的
        3- setState（）更改数据，constructor只是在初次渲染时调用；而render函数会调用多次，每一个数据更改都会调用  




### 3. refs与事件处理

## 9.一些说明
### 1- 在react框架使用的过程中，会使用babel，此时会在全局和局部使用严格模式（'use strict'） 
### 2- 在react的事件处理函数中绑定的事件函数都是window对象来调用的，不是组件的实例对象调用的。因此事件处理函数的this是指向window的。